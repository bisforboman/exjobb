\chapter{Theory}

% maybe talk something about the breadcrumbs that lead me to where I am now?

This chapter provides an introduction to the various concepts used throughout the thesis. First we explain \textit{Formal Verification}, following it up with \textit{Model Checking} and its' strengths and weaknesses. Finally some introduction to the model checking tool \textit{SPIN}, Simple Promela INterpreter, and its' input language \textit{Promela}.

% approach ->
% As a starting point, I will consider a WSN where data is collected by sensors and then centrally processed by a server. Here the decision would be processed by the central unit and then propagated back to the sensors. Once the features of the decision procedure is characterized in this simple setting, I will then look at introducing more distributed computation capabilities in the network - e.g. by adding aggregators to manage a set of sensors or equipping all sensors with a computation unit to allow each of them to make decisions. To this aim, a computation unit would need to know what should be computed, how it should be computed and what has already been computed. This will allow the unit to decide if further collection is needed. 

% unit testing vs formal verification
%To analyze the system we wanted to improve, the project investigated different ways to design and verify a \wsn . For verifying, the two most relevant options were formal verification and testing (e.g. unit-testing) \todo{talk more about testing?}. Unit-testing is the technique of \ldots

%Formal verification on the other hand means that you, by logic, prove certain properties of the system and by so making sure the system works as intended. % really?

\section{Formal Verification}

The act of formal verification means to make use of mathematical techniques to make sure that a design upholds a defined functional correctness\cite{bjesse2005formal}.
This means, that if we assume we have the following: a model of a design, a description of the environment where the design is supposed to operate in and some properties we wish the design to uphold. With this information, one may want to construct some input sequences, that are in the allowed in domain of the environment, that would violate the properties stated. A common practice for finding such patterns today are random simulations or directed tests.
Formal verification allows for an extended approach to this, as it allows both to search for input sequences that violates the properties but also allows to mathematically prove that the stated properties holds when no input sequences exist.

\section{Model Checking}

A traditional approach to verifying concurrent systems is based on using extensive testing and simulation to find and eliminate unwanted occurrences from the system, but this way can easily miss crucial errors when the system that's being tested has a large number of possible states\cite{clarke1999model}. An alternative technique that was developed in the 1980's by Clarke et al. is called \textit{temporal logic model checking} or "Model Checking".

Model Checking is an automated technique to verify finite state concurrent systems, by letting a tool verify that a model holds for certain properties. The process of applying Model Checking to a design is separated into several tasks; \textit{modeling}, \textit{specification} and \textit{verification}. \\

\begin{itemize}
	\item[] \textbf{Modeling:} First task is to translate a design into a format which is accepted by a model checking tool. This is either a compilation task or a task in abstracting certain aspects of the design to eliminate irrelevant or unimportant details, due to limitations on time an memory. \\
	\item[] \textbf{Specification:} Second task is to state which properties the design is supposed to have. This is usually done using in a logical formalism, commonly in temporal logic, which can express assertions on a system evolving over time. \\
	\item[] \textbf{Verification:} The final step is allowing the tool to verify the specification on the model. This will either be a positive result, meaning the model satisfies the properties, or a negative result where the properties aren't. A negative result can also be that the model's state space is too large to fit into a computer, which will require the model to be further abstracted to be verified.
\end{itemize}


\subsection{Model Checking Workflow}

%\textit{show a structure of a model checking workflow}\todo{show structure of model checking workflow}

The use of model checking in practice typically follows the workflow in Figure \textit{insert ref here}. A design is translated into a description, that the model checker can read, and a specification of wanted or unwanted behavior is translated into a property. Then the model checker will produce a result which is either that the property is upheld or an error explaining how the property is invalidated. 

%\subsection{LTL property verification}
% might be a useful subchapter to introduce "specification"
\subsection{Problem space reduction}

\textit{will explain the problems with having a to precise model}\todo{mention the problem with state space explosion}

\section{SPIN}

The model checking tool used in this thesis is called SPIN, an abbreviation of Simple Promela Interpreter. The SPIN tool allows to create an abstract model of a system, specifying properties that the model must hold and then verify them to see if there is possible system state that invalidates it. SPIN verification models are focused on proving the correctness of process interactions.\cite{holzmann1997model} Process interactions can be specified in several ways using SPIN; rendevouz primitives, asynchronous message passing, shared variables or a combination of these. 

% discuss difference from SPIN to other tools?

% discuss how you can use SPIN to find errors

\subsection{Promela}
Promela is a specification language with its' focus on modeling process synchronization and coordination rather than computation. Therefore the language targets the description of conurrent software systems, rather than the description of hardware circuits, which is more common for other model checking applications\cite{holzmann1997model}.
The features in the Promela language allows for description of concurrent processes and communication through message passing over buffered or rendevouz(unbuffered) channels.  

% discuss the simplicity of promela for reaching better abstraction

\subsubsection{Promela Example}

To give an impression of Promela's syntax, Listing~\ref{lst:example} serves as an small example that captures most of the concepts used in this thesis. The example models an environment, receiving a \texttt{meter}-request on \texttt{envChan}. Then the process undeterministically choses one of the two responses in the guard statement and responds back on the same channel. Worth noting is that most part of the model is captured in an \texttt{atomic}-statement, this means that when the request is received, this process will be allowed to execute the rest of the \texttt{atomic}-statement without any interleaving. 
Since this process flow isn't realistic in a concurrent system, where interleaving is prone to occur, all usage of \texttt{atomic} has to be explained and carefully motivated. 

\begin{lstlisting}[caption={Promela Example},label={lst:example},language=Promela, numbers=left, basicstyle=\footnotesize, tabsize=2]
active proctype Environment() {

Idle:  
	if
	:: atomic { 
		envChan ? meter ->  
			if
			:: envChan ! bigData;
			:: envChan ! smallData;
			fi; 
			goto Idle;
	}
	fi;
}
\end{lstlisting}

\subsection{Properties in SPIN}

% The properties SPIN accepts are specified in Linear Time Logic. 

In order to prove or disprove a property using SPIN, we must first state them in some formal notation. This can be done by either using \texttt{assertion}-statements, to ensure a property at a certain point in time, or using LTL to prove properties over an entire system trace. 
Except the operators inherited from propositional logic (\textit{negation}, \textit{conjunction}, \textit{equivalence}, \textit{implication}, etc.) LTL also provides the temporal operators such as \textit{always}, \textit{eventually} and \textit{until}. \todo{include reference} 

\begin{itemize}
	\item[] \textbf{Always} ($\Box$) states that a property has to hold on the entire subsequent path\todo{mention what subsequent path means}, e.g $\Box a$ means that the condition $a$ always holds true. In promela this is either written as \texttt{always} or \texttt{[]}.
	\item[] \textbf{Eventually} ($\Diamond$) states that a property has to hold somewhere on the subsequent path, meaning that $\Diamond a$ means that $a$ must hold in the current state or in some future state. This is written in promela as \texttt{<>} or \texttt{eventually}.
	\item[] \textbf{Until} ($U$) captures a relative behavior between two condditions, e.g. $a \text{ U } b$ means that $a$ must hold true atleast until $b$ holds true. In promela this is written as \texttt{U} or \texttt{until}.
 \end{itemize}

For a complete description of the LTL properties available, and their semantics in SPIN, see Holzmann (2003, p. 135-139).

\subsubsection{Specification}

% how do properties look in spin?
Spin allows us to either prove properties that always should hold true (safety properties) or error behaviors (i.e. properties that should never hold). When verifying safety properties in Spin, instead of trying to prove that a property holds true in each possible system state, it tries to find a state in which the property is invalidated. 

% explain that this is due to effiency

\subsubsection{Verification}



% how do spin verify properties?

\section{Related Work}
\subsection{Smart City} 

\textit{some background into their approach}\cite{li2016privacy}

\textit{some comparison to this project}

%*discuss smart city's approach in difference to your own*

\subsection{Privacy Enhancing Technologies (PET)}
\label{section:SmartCity}

\textit{compare this to your work}
%find surveys regarding this
