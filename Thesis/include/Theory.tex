\chapter{Theory}

% maybe talk something about the breadcrumbs that lead me to where I am now?

This chapter provides an introduction to the various concepts used throughout the thesis. First we explain \textit{Formal Verification}, following it up with \textit{Model Checking} and its' strengths and weaknesses. Finally some introduction to the model checking tool \textit{SPIN}, Simple Promela INterpreter, and its' input language \textit{Promela}.

% approach ->
% As a starting point, I will consider a WSN where data is collected by sensors and then centrally processed by a server. Here the decision would be processed by the central unit and then propagated back to the sensors. Once the features of the decision procedure is characterized in this simple setting, I will then look at introducing more distributed computation capabilities in the network - e.g. by adding aggregators to manage a set of sensors or equipping all sensors with a computation unit to allow each of them to make decisions. To this aim, a computation unit would need to know what should be computed, how it should be computed and what has already been computed. This will allow the unit to decide if further collection is needed. 

% unit testing vs formal verification
%To analyze the system we wanted to improve, the project investigated different ways to design and verify a \wsn . For verifying, the two most relevant options were formal verification and testing (e.g. unit-testing) \todo{talk more about testing?}. Unit-testing is the technique of \ldots

%Formal verification on the other hand means that you, by logic, prove certain properties of the system and by so making sure the system works as intended. % really?

\section{Formal Verification}

The act of formal verification means to make use of mathematical techniques to make sure that a design upholds a defined functional correctness\cite{bjesse2005formal}.
This means, that if we assume we have the following: a model of a design, a description of the environment where the design is supposed to operate in and some properties we wish the design to uphold. With this information, one may want to construct some input sequences, that are in the allowed in domain of the environment, that would violate the properties stated. A common practice for finding such patterns today are random simulations or directed tests.
Formal verification allows for an extended approach to this, as it allows both to search for input sequences that violates the properties but also allows to mathematically prove that the stated properties holds when no input sequences exist.

\section{Model Checking}

A traditional approach to verifying concurrent systems is based on using extensive testing and simulation to find and eliminate unwanted occurrences from the system, but this way can easily miss crucial errors when the system that's being tested has a large number of possible states\cite{clarke1999model}. An alternative technique that was developed in the 1980's by Clarke et al. is called \textit{temporal logic model checking} or "Model Checking".

Model Checking is an automated technique to verify finite state concurrent systems, by letting a tool verify that a model holds for certain properties. The process of applying Model Checking to a design is separated into several tasks; \textit{modeling}, \textit{specification} and \textit{verification}. \\

\begin{itemize}
\item[] \textbf{Modeling:} First task is to translate a design into a format which is accepted by a model checking tool. This is either a compilation task or a task in abstracting certain aspects of the design to eliminate irrelevant or unimportant details, due to limitations on time an memory. \\
\item[] \textbf{Specification:} Second task is to state which properties the design is supposed to have. This is usually done using in a logical formalism, commonly in temporal logic, which can express assertions on a system evolving over time. \\
\item[] \textbf{Verification:} The final step is allowing the tool to verify the specification on the model. This will either be a positive result, meaning the model satisfies the properties, or a negative result where the properties aren't. A negative result can also be that the model's state space is too large to fit into a computer, which will require the model to be further abstracted to be verified.
\end{itemize}


\subsection{Model Checking Workflow}

%\textit{show a structure of a model checking workflow}\todo{show structure of model checking workflow}

The use of model checking in practice typically follows the workflow in Figure \textit{insert ref here}. A design is translated into a description, that the model checker can read, and a specification of wanted or unwanted behavior is translated into a property. Then the model checker will produce a result which is either that the property is upheld or an error explaining how the property is invalidated. 

%\subsection{LTL property verification}
% might be a useful subchapter to introduce "specification"
\subsection{Problem space reduction}

\textit{will explain the problems with having a to precise model}\todo{mention the problem with state space explosion}

\section{SPIN}

The model checking tool used for this project is called Simple Promela Interpreter (SPIN) and the language it accepts is called Promela, which is an acronym for Process Meta Language. 

\textit{some history of SPIN}

\textit{describe usages of SPIN}

\section{Promela}

\textit{discuss promela}

\subsection{Semantics}

\textit{show some semantics}

\section{Related Work}
\subsection{Smart City} 

\textit{some background into their approach}\cite{li2016privacy}

\textit{some comparison to this project}

%*discuss smart city's approach in difference to your own*

\subsection{Privacy Enhancing Technologies (PET)}
\label{section:SmartCity}

\textit{compare this to your work}
%find surveys regarding this
